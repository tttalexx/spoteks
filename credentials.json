1import logging
from termcolor import colored
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, ConversationHandler, CallbackQueryHandler
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from datetime import datetime

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levellevel)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

logger.info("Starting bot...")

try:
    # Подключение к Google Sheets
    scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
    creds = ServiceAccountCredentials.from_json_keyfile_name('credentials.json', scope)
    client = gspread.authorize(creds)
    logger.info("Connected to Google Sheets API.")
    import logging
    from termcolor import colored
    from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton
    from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, ConversationHandler, CallbackQueryHandler
    import gspread
    from oauth2client.service_account import ServiceAccountCredentials
    from datetime import datetime
    
    # Настройка логирования
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    logger.info("Starting bot...")
    
    try:
        # Подключение к Google Sheets
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = ServiceAccountCredentials.from_json_keyfile_name('credentials.json', scope)
        client = gspread.authorize(creds)
        logger.info("Connected to Google Sheets API.")
        
        # Открытие нужных листов
        orders_sheet = client.open("SPOTEKS_main").worksheet("ORDERS")
        actual_price_sheet = client.open("SPOTEKS_main").worksheet("actual_price")
        user_sheet = client.open("SPOTEKS_main").worksheet("user_db")
        regions_sheet = client.open("SPOTEKS_main").worksheet("db_regions")
        culture_sheet = client.open("SPOTEKS_main").worksheet("db_culture")
    
        logger.info("Opened all necessary sheets.")
        
        # Вывод сообщения об успешном запуске
        print(colored("Бот запустился успешно, работает", "green"))
    
    except gspread.SpreadsheetNotFound:
        logger.error("Google Sheet not found. Please check the sheet name.")
        print(colored("Ошибка: Google Sheet не найден. Проверьте имя таблицы.", "red"))
    except gspread.WorksheetNotFound:
        logger.error("Google Worksheet not found. Please check the worksheet name.")
        print(colored("Ошибка: Лист Google не найден. Проверьте имя листа.", "red"))
    except Exception as e:
        logger.error(f"Error connecting to Google Sheets: {e}")
        print(colored("Ошибка при запуске бота", "red"))
    
    # Константы состояний для ConversationHandler
    FIO, PHONE, TELEGRAM_LOGIN, CULTURE, VOLUME, REGION, LOAD_PLACE, UNLOAD_PLACE, PRICE, CONFIRM = range(10)
    
    # Словарь для хранения данных пользователей
    user_data = {}
    
    async def start(update: Update, context: CallbackContext) -> None:
        # Ваш код для обработки команды /start
        pass
    
    # Ваш основной код для запуска ботаimport logging
    from termcolor import colored
    from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton
    from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, ConversationHandler, CallbackQueryHandler
    import gspread
    from oauth2client.service_account import ServiceAccountCredentials
    from datetime import datetime
    
    # Настройка логирования
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    logger.info("Starting bot...")
    
    try:
        # Подключение к Google Sheets
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = ServiceAccountCredentials.from_json_keyfile_name('credentials.json', scope)
        client = gspread.authorize(creds)
        logger.info("Connected to Google Sheets API.")
        
        # Открытие нужных листов
        orders_sheet = client.open("SPOTEKS_main").worksheet("ORDERS")
        actual_price_sheet = client.open("SPOTEKS_main").worksheet("actual_price")
        user_sheet = client.open("SPOTEKS_main").worksheet("user_db")
        regions_sheet = client.open("SPOTEKS_main").worksheet("db_regions")
        culture_sheet = client.open("SPOTEKS_main").worksheet("db_culture")
    
        logger.info("Opened all necessary sheets.")
        
        # Вывод сообщения об успешном запуске
        print(colored("Бот запустился успешно, работает", "green"))
    
    except gspread.SpreadsheetNotFound:
        logger.error("Google Sheet not found. Please check the sheet name.")
        print(colored("Ошибка: Google Sheet не найден. Проверьте имя таблицы.", "red"))
    except gspread.WorksheetNotFound:
        logger.error("Google Worksheet not found. Please check the worksheet name.")
        print(colored("Ошибка: Лист Google не найден. Проверьте имя листа.", "red"))
    except Exception as e:
        logger.error(f"Error connecting to Google Sheets: {e}")
        print(colored("Ошибка при запуске бота", "red"))
    
    # Константы состояний для ConversationHandler
    FIO, PHONE, TELEGRAM_LOGIN, CULTURE, VOLUME, REGION, LOAD_PLACE, UNLOAD_PLACE, PRICE, CONFIRM = range(10)
    
    # Словарь для хранения данных пользователей
    user_data = {}
    
    async def start(update: Update, context: CallbackContext) -> None:
        # Ваш код для обработки команды /start
        pass
    
    # Ваш основной код для запуска ботаimport logging
    from termcolor import colored
    from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton
    from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, ConversationHandler, CallbackQueryHandler
    import gspread
    from oauth2client.service_account import ServiceAccountCredentials
    from datetime import datetime
    
    # Настройка логирования
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    logger.info("Starting bot...")
    
    try:
        # Подключение к Google Sheets
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = ServiceAccountCredentials.from_json_keyfile_name('credentials.json', scope)
        client = gspread.authorize(creds)
        logger.info("Connected to Google Sheets API.")
        
        # Открытие нужных листов
        orders_sheet = client.open("SPOTEKS_main").worksheet("ORDERS")
        actual_price_sheet = client.open("SPOTEKS_main").worksheet("actual_price")
        user_sheet = client.open("SPOTEKS_main").worksheet("user_db")
        regions_sheet = client.open("SPOTEKS_main").worksheet("db_regions")
        culture_sheet = client.open("SPOTEKS_main").worksheet("db_culture")
    
        logger.info("Opened all necessary sheets.")
        
        # Вывод сообщения об успешном запуске
        print(colored("Бот запустился успешно, работает", "green"))
    
    except gspread.SpreadsheetNotFound:
        logger.error("Google Sheet not found. Please check the sheet name.")
        print(colored("Ошибка: Google Sheet не найден. Проверьте имя таблицы.", "red"))
    except gspread.WorksheetNotFound:
        logger.error("Google Worksheet not found. Please check the worksheet name.")
        print(colored("Ошибка: Лист Google не найден. Проверьте имя листа.", "red"))
    except Exception as e:
        logger.error(f"Error connecting to Google Sheets: {e}")
        print(colored("Ошибка при запуске бота", "red"))
    
    # Константы состояний для ConversationHandler
    FIO, PHONE, TELEGRAM_LOGIN, CULTURE, VOLUME, REGION, LOAD_PLACE, UNLOAD_PLACE, PRICE, CONFIRM = range(10)
    
    # Словарь для хранения данных пользователей
    user_data = {}
    
    async def start(update: Update, context: CallbackContext) -> None:
        # Ваш код для обработки команды /start
        pass
    
    # Ваш основной код для запуска ботаimport logging
    from termcolor import colored
    from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton
    from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, ConversationHandler, CallbackQueryHandler
    import gspread
    from oauth2client.service_account import ServiceAccountCredentials
    from datetime import datetime
    
    # Настройка логирования
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    logger.info("Starting bot...")
    
    try:
        # Подключение к Google Sheets
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = ServiceAccountCredentials.from_json_keyfile_name('credentials.json', scope)
        client = gspread.authorize(creds)
        logger.info("Connected to Google Sheets API.")
        
        # Открытие нужных листов
        orders_sheet = client.open("SPOTEKS_main").worksheet("ORDERS")
        actual_price_sheet = client.open("SPOTEKS_main").worksheet("actual_price")
        user_sheet = client.open("SPOTEKS_main").worksheet("user_db")
        regions_sheet = client.open("SPOTEKS_main").worksheet("db_regions")
        culture_sheet = client.open("SPOTEKS_main").worksheet("db_culture")
    
        logger.info("Opened all necessary sheets.")
        
        # Вывод сообщения об успешном запуске
        print(colored("Бот запустился успешно, работает", "green"))
    
    except gspread.SpreadsheetNotFound:
        logger.error("Google Sheet not found. Please check the sheet name.")
        print(colored("Ошибка: Google Sheet не найден. Проверьте имя таблицы.", "red"))
    except gspread.WorksheetNotFound:
        logger.error("Google Worksheet not found. Please check the worksheet name.")
        print(colored("Ошибка: Лист Google не найден. Проверьте имя листа.", "red"))
    except Exception as e:
        logger.error(f"Error connecting to Google Sheets: {e}")
        print(colored("Ошибка при запуске бота", "red"))
    
    # Константы состояний для ConversationHandler
    FIO, PHONE, TELEGRAM_LOGIN, CULTURE, VOLUME, REGION, LOAD_PLACE, UNLOAD_PLACE, PRICE, CONFIRM = range(10)
    
    # Словарь для хранения данных пользователей
    user_data = {}
    
    async def start(update: Update, context: CallbackContext) -> None:
        # Ваш код для обработки команды /start
        pass
    
    # Ваш основной код для запуска ботаimport logging
    from termcolor import colored
    from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton
    from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, ConversationHandler, CallbackQueryHandler
    import gspread
    from oauth2client.service_account import ServiceAccountCredentials
    from datetime import datetime
    
    # Настройка логирования
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
    )
    logger = logging.getLogger(__name__)
    
    logger.info("Starting bot...")
    
    try:
        # Подключение к Google Sheets
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = ServiceAccountCredentials.from_json_keyfile_name('credentials.json', scope)
        client = gspread.authorize(creds)
        logger.info("Connected to Google Sheets API.")
        
        # Открытие нужных листов
        orders_sheet = client.open("SPOTEKS_main").worksheet("ORDERS")
        actual_price_sheet = client.open("SPOTEKS_main").worksheet("actual_price")
        user_sheet = client.open("SPOTEKS_main").worksheet("user_db")
        regions_sheet = client.open("SPOTEKS_main").worksheet("db_regions")
        culture_sheet = client.open("SPOTEKS_main").worksheet("db_culture")
    
        logger.info("Opened all necessary sheets.")
        
        # Вывод сообщения об успешном запуске
        print(colored("Бот запустился успешно, работает", "green"))
    
    except gspread.SpreadsheetNotFound:
        logger.error("Google Sheet not found. Please check the sheet name.")
        print(colored("Ошибка: Google Sheet не найден. Проверьте имя таблицы.", "red"))
    except gspread.WorksheetNotFound:
        logger.error("Google Worksheet not found. Please check the worksheet name.")
        print(colored("Ошибка: Лист Google не найден. Проверьте имя листа.", "red"))
    except Exception as e:
        logger.error(f"Error connecting to Google Sheets: {e}")
        print(colored("Ошибка при запуске бота", "red"))
    
    # Константы состояний для ConversationHandler
    FIO, PHONE, TELEGRAM_LOGIN, CULTURE, VOLUME, REGION, LOAD_PLACE, UNLOAD_PLACE, PRICE, CONFIRM = range(10)
    
    # Словарь для хранения данных пользователей
    user_data = {}
    
    async def start(update: Update, context: CallbackContext) -> None:
        # Ваш код для обработки команды /start
        pass
    
    # Ваш основной код для запуска бота
    # Открытие нужных листов
    orders_sheet = client.open("SPOTEKS_main").worksheet("ORDERS")
    actual_price_sheet = client.open("SPOTEKS_main").worksheet("actual_price")
    user_sheet = client.open("SPOTEKS_main").worksheet("user_db")
    regions_sheet = client.open("SPOTEKS_main").worksheet("db_regions")
    culture_sheet = client.open("SPOTEKS_main").worksheet("db_culture")

    logger.info(f"Opened all necessary sheets.")
    
    # Вывод сообщения об успешном запуске
    print(colored("Бот запустился успешно, работает", "green"))

except gspread.SpreadsheetNotFound:
    logger.error("Google Sheet not found. Please check the sheet name.")
    print(colored("Ошибка: Google Sheet не найден. Проверьте имя таблицы.", "red"))
except gspread.WorksheetNotFound:
    logger.error("Google Worksheet not found. Please check the worksheet name.")
    print(colored("Ошибка: Лист Google не найден. Проверьте имя листа.", "red"))
except Exception as e:
    logger.error(f"Error connecting to Google Sheets: {e}")
    print(colored("Ошибка при запуске бота", "red"))

# Константы состояний для ConversationHandler
FIO, PHONE, TELEGRAM_LOGIN, CULTURE, VOLUME, REGION, LOAD_PLACE, UNLOAD_PLACE, PRICE, CONFIRM = range(10)

# Словарь для хранения данных пользователей
user_data = {}

async def start(update: Update, context: CallbackContext) -> None:
    keyboard = [['Актуальные цены', 'Подать заявку'], ['Мои заявки', 'Обновить заявку', 'Удалить заявку']]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text("Выберите действие:", reply_markup=reply_markup)

async def check_prices(update: Update, context: CallbackContext) -> None:
    try:
        # Получаем данные о ценах из Google Sheets
        prices_data = actual_price_sheet.get_all_values()
        columns = prices_data[0]
        update_time = actual_price_sheet.cell(1, 1).value  # Дата и время актуализации цен
        response = f"Цены актуальны на {update_time}:\n\n"

        for row in prices_data[1:]:
            if any(row[1:]):  # Проверяем, есть ли цены в строке
                product = row[0]
                valid_prices = [f"▫️ {columns[i]} - {price} грн/т" for i, price in enumerate(row[1:], 1) if price]
                if valid_prices:
                    response += f"{product}\n" + "\n".join(valid_prices) + "\n\n"
        
        await update.message.reply_text(response.strip())
    except Exception as e:
        logger.error(f"Error checking prices: {e}")

async def apply(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    try:
        user_records = user_sheet.get_all_records()
        user = next((user for user in user_records if str(user['telegram_id']) == str(user_id)), None)

        if user:
            user_data[user_id] = {
                'telegram_id': user['telegram_id'],
                'telegram_login': user['telegram_login'],
                'tel': user['tel'],
                'name': user['name']
            }
            await update.message.reply_text("Выберите культуру:", reply_markup=generate_culture_keyboard())
            return CULTURE
        else:
            contact_button = KeyboardButton("Отправить контакт", request_contact=True)
            reply_markup = ReplyKeyboardMarkup([[contact_button]], resize_keyboard=True, one_time_keyboard=True)
            await update.message.reply_text("Пожалуйста, отправьте ваш контакт для регистрации:", reply_markup=reply_markup)
            return PHONE
    except Exception as e:
        logger.error(f"Error checking user in apply: {e}")
        await update.message.reply_text("Произошла ошибка при проверке пользователя. Пожалуйста, попробуйте позже.")
        return ConversationHandler.END

async def phone(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    user_data[user_id] = {
        'tel': update.message.contact.phone_number,
        'telegram_id': update.message.contact.user_id,
        'telegram_login': update.message.from_user.username or "NoUsername"
    }
    await update.message.reply_text("Введите ваше ФИО:")
    return FIO

async def fio(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    user_data[user_id]['name'] = update.message.text

    try:
        # Сохранение данных в Google Sheets
        user_sheet.append_row([user_data[user_id]['telegram_id'], user_data[user_id]['telegram_login'], user_data[user_id]['tel'], user_data[user_id]['name']])
        # Продолжение подачи заявки
        await update.message.reply_text("Вы зарегистрированы. Теперь выберите культуру:", reply_markup=generate_culture_keyboard())
        return CULTURE
    except Exception as e:
        logger.error(f"Error saving user data in fio: {e}")
        await update.message.reply_text("Произошла ошибка при сохранении данных пользователя. Пожалуйста, попробуйте позже.")
        return ConversationHandler.END

def generate_culture_keyboard():
    try:
        # Получаем данные о культурах из Google Sheets
        cultures_data = culture_sheet.get_all_values()
        cultures = [row[0] for row in cultures_data]  # Список культур
        keyboard = [cultures[i:i+2] for i in range(0, len(cultures), 2)]
        keyboard.append(["Назад"])
        return ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
    except Exception as e:
        logger.error(f"Error generating culture keyboard: {e}")
        return ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True)

def generate_region_keyboard():
    try:
        regions_data = regions_sheet.get_all_values()
        regions = [row[0] for row in regions_data]  # Список регионов
        keyboard = [regions[i:i+2] for i in range(0, len(regions), 2)]
        keyboard.append(["Назад"])
        return ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
    except Exception as e:
        logger.error(f"Error generating region keyboard: {e}")
        return ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True)

async def culture(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    if update.message.text == "Назад":
        await start(update, context)
        return ConversationHandler.END
    user_data[user_id]['culture'] = update.message.text
    await update.message.reply_text("Введите объем (т):", reply_markup=ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True))
    return VOLUME

async def volume(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    if update.message.text == "Назад":
        await update.message.reply_text("Выберите культуру:", reply_markup=generate_culture_keyboard())
        return CULTURE
    user_data[user_id]['weight'] = update.message.text

    await update.message.reply_text("Выберите область:", reply_markup=generate_region_keyboard())
    return REGION

async def region(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    if update.message.text == "Назад":
        await update.message.reply_text("Введите объем (т):", reply_markup=ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True))
        return VOLUME
    user_data[user_id]['load_region'] = update.message.text
    await update.message.reply_text("Введите место отгрузки:", reply_markup=ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True))
    return LOAD_PLACE

async def load_place(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    if update.message.text == "Назад":
        await update.message.reply_text("Выберите область:", reply_markup=generate_region_keyboard())
        return REGION
    user_data[user_id]['load_place'] = update.message.text
    await update.message.reply_text("Введите место выгрузки:", reply_markup=ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True))
    return UNLOAD_PLACE

async def unload_place(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    if update.message.text == "Назад":
        await update.message.reply_text("Введите место отгрузки:", reply_markup=ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True))
        return LOAD_PLACE
    user_data[user_id]['unload_place'] = update.message.text
    await update.message.reply_text("Введите цену с места (грн):", reply_markup=ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True))
    return PRICE

async def price(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    if user_id not in user_data:
        user_data[user_id] = {}
    if update.message.text == "Назад":
        await update.message.reply_text("Введите место выгрузки:", reply_markup=ReplyKeyboardMarkup([["Назад"]], one_time_keyboard=True, resize_keyboard=True))
        return UNLOAD_PLACE
    user_data[user_id]['order_price'] = update.message.text
    
    # Подтверждение перед добавлением
    keyboard = [
        [InlineKeyboardButton("Подтвердить", callback_data='confirm')],
        [InlineKeyboardButton("Отменить", callback_data='cancel')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        f"Проверьте данные:\n"
        f"ФИО: {user_data[user_id]['name']}\n"
        f"Культура: {user_data[user_id]['culture']}\n"
        f"Объем: {user_data[user_id]['weight']}\n"
        f"Область: {user_data[user_id]['load_region']}\n"
        f"Место отгрузки: {user_data[user_id]['load_place']}\n"
        f"Место выгрузки: {user_data[user_id]['unload_place']}\n"
        f"Цена с места: {user_data[user_id]['order_price']}",
        reply_markup=reply_markup)
    return CONFIRM

async def confirm(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    user_id = query.from_user.id
    await query.answer()
    
    try:
        # Генерация ID заявки
        all_records = orders_sheet.get_all_records()
        orderID = f"ID_{len(all_records) + 1}"
        date = datetime.now().strftime("%Y-%m-%d %H:%M")
        
        # Сохраняем данные в Google Sheets
        logger.info(f"Preparing to append row: {orderID}, {user_data[user_id].get('name', '')}, {user_data[user_id]['culture']}, {user_data[user_id]['weight']}, {user_data[user_id]['load_region']}, {user_data[user_id]['load_place']}, {user_data[user_id]['unload_place']}, {user_data[user_id]['order_price']}, {user_id}")
        orders_sheet.append_row([
            date,
            '',  # Менеджер
            orderID,
            user_data[user_id]['culture'],
            user_data[user_id]['weight'],
            'Ожидание',  # Статус заявки
            user_data[user_id]['load_region'],
            user_data[user_id]['load_place'],
            user_data[user_id]['unload_place'],
            user_data[user_id]['order_price'],
            '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''
        ])
        logger.info(f"Successfully added new application: {orderID}, {user_data[user_id]}")

        await query.edit_message_text(f"Ваша заявка принята! Номер заявки: {orderID}")

        # Показать главное меню
        await start(query, context)
    except gspread.exceptions.APIError as e:
        logger.error(f"API error while adding application: {e}")
        await query.edit_message_text("Произошла ошибка при добавлении заявки. Пожалуйста, попробуйте позже.")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await query.edit_message_text("Произошла непредвиденная ошибка. Пожалуйста, попробуйте позже.")
    return ConversationHandler.END

async def cancel(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("Заявка отменена.")
    await start(query, context)
    return ConversationHandler.END

async def view_applications(update: Update, context: CallbackContext) -> None:
    user_id = update.message.from_user.id
    try:
        all_records = orders_sheet.get_all_records()
        user_records = user_sheet.get_all_records()
        
        # Поиск имени пользователя в листе user_sheet
        user = next((user for user in user_records if str(user['telegram_id']) == str(user_id)), None)
        user_name = user['name'] if user else "Неизвестный пользователь"
    
        # Поиск заявок данного пользователя
        user_applications = [record for record in all_records if 'telegram_id' in record and str(record['telegram_id']) == str(user_id)]
    
        if user_applications:
            response = f"Ваши заявки, {user_name}:\n"
            for application in user_applications:
                response += (f"ID заявки: {application['orderID']}\n"
                             f"Дата: {application['order_date']}\n"
                             f"Культура: {application['culture']}\n"
                             f"Объем, т: {application['weight']}\n"
                             f"Область: {application['load_region']}\n"
                             f"Место отгрузки: {application['load_place']}\n"
                             f"Место выгрузки: {application['unload_place']}\n"
                             f"Цена с места, грн: {application['order_price']}\n\n")
            await update.message.reply_text(response)
        else:
            await update.message.reply_text("У вас нет поданных заявок.")
    except Exception as e:
        logger.error(f"Error viewing applications: {e}")

async def update_application(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text("Введите orderID заявки, которую вы хотите обновить:")

async def delete_application(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text("Введите orderID заявки, которую вы хотите удалить:")

def main() -> None:
    # Используем ваш реальный Telegram Bot ID
    application = Application.builder().token("6679900044:AAGDIGrEGjq_jTK3_5tzXm_qGLLNuCY4Tgc").build()

    # Определение ConversationHandler для обработки заявок
    conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex('^(Подать заявку)$'), apply)],
        states={
            PHONE: [MessageHandler(filters.CONTACT, phone)],
            FIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, fio)],
            CULTURE: [MessageHandler(filters.TEXT & ~filters.COMMAND, culture)],
            VOLUME: [MessageHandler(filters.TEXT & ~filters.COMMAND, volume)],
            REGION: [MessageHandler(filters.TEXT & ~filters.COMMAND, region)],
            LOAD_PLACE: [MessageHandler(filters.TEXT & ~filters.COMMAND, load_place)],
            UNLOAD_PLACE: [MessageHandler(filters.TEXT & ~filters.COMMAND, unload_place)],
            PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, price)],
            CONFIRM: [CallbackQueryHandler(confirm, pattern='^confirm$'),
                      CallbackQueryHandler(cancel, pattern='^cancel$')],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )

    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.Regex('^(Актуальные цены)$'), check_prices))
    application.add_handler(MessageHandler(filters.Regex('^(Мои заявки)$'), view_applications))
    application.add_handler(MessageHandler(filters.Regex('^(Обновить заявку)$'), update_application))
    application.add_handler(MessageHandler(filters.Regex('^(Удалить заявку)$'), delete_application))
    application.add_handler(conv_handler)

    # Запуск бота
    application.run_polling()

if __name__ == '__main__':
    main()